#!/usr/bin/env python3

"""
auto-techsupport script.
    This script is invoked by the techsupport-monit.service & coredump-monit.service 
    for auto techsupport invocation and cleanup of techsupport & core dumps. 
    For more info, refer to the HLD
"""
import os
import sys
import glob
import time
import argparse
import subprocess
import syslog
from swsssdk import SonicV2Connector


AUTO_TS = "AUTO_TECHSUPPORT|global"
CFG_DB = "CONFIG_DB"
CFG_STATE = "state"
CFG_MAX_TS = "max-techsupports"
CFG_CORE_USAGE = "core-usage"
# STATE_DB = "STATE_DB"
# LAST_TS = "last_techsupport_run"
# PREV_TS_COUNT = "num_techsupports"
# CORE_FILE_LIST = "core_file_list"
TS_DIR = "/var/dump"
CORE_DUMP_DIR = "/var/core"
TS_PTRN = "sonic_dump_*.tar.gz"
CORE_DUMP_PTRN = "*.core.gz"
# TS_WAIT_TIMEOUT = 300

# DEFAULT_SCHEMA_STATE = {PREV_TS_COUNT : "", LAST_TS : "", CORE_FILE_LIST : ""} 


def main():
    parser = argparse.ArgumentParser(description='Auto Techsupport Invocation and Management Script')
    parser.add_argument('mode', type=str, choices=['core', 'techsupport'])
    args = parser.parse_args()
    
    syslog.openlog(logoption=syslog.LOG_PID)
    
    if args.mode == "core":
        handle_core_dump_creation_event()
    else:
        handle_techsupport_creation_event()
    
def handle_core_dump_creation_event():
    pass

def handle_techsupport_creation_event():
    """ 
    This method is invoked notified when there is a notification from systemd when something is changed in /var/dump/ directory
    Only if the feature is enabled by the user, the Techsupport cleanup process will be initiated. 
    The TS cleanup proces will delete the old techsupport dumps, when the actual number crosses the 'max-techsupports' limit configured by the user. 
    """
#     last_ts = str(time.monotonic())
    
    curr_list = glob.glob(os.path.join(TS_DIR, TS_PTRN))
    curr_list.sort()
    num_cur_ts = len(curr_list)
    print("Reached Here...")
    if num_cur_ts == 0:
        syslog.syslog(syslog.LOG_DEBUG, "Ignoring the notification, as it wasn't because of the Techsupport dump creation")
        return  
    
    if not verify_recent_file_creation(curr_list[-1]):
        syslog.syslog(syslog.LOG_DEBUG, "Ignoring the notification, as it wasn't because of the Techsupport dump creation")    
        return 

    cfg_db = SonicV2Connector(host="127.0.0.1")
    cfg_db.connect(CFG_DB)
    
    if cfg_db.get(CFG_DB, AUTO_TS, CFG_STATE) == "enabled":
        max_ts = cfg_db.get(CFG_DB, AUTO_TS, CFG_MAX_TS)
        if not max_ts:
            syslog.syslog(syslog.LOG_INFO, "max-techsupports is not set. No TechSupport Cleanup Process is needed to be performed, current number of dumps: {}".format(num_cur_ts))
            return  
        max_ts = int(max_ts)
    else:
        syslog.syslog(syslog.LOG_INFO, "AUTO_TECHSUPPORT is not enabled. No TechSupport Cleanup Process is performed, current number of dumps: {}".format(num_cur_ts))
        return 
    print("Reached Here...")
    # Cleanup Checks
    num_del = num_cur_ts - max_ts
    if num_del <= 0:
        return 
    print("Reached Here...")
    # Perform Cleanup
    dumps_to_del = curr_list[0:num_del]
    syslog.syslog(syslog.LOG_DEBUG, "{} dumps will be deleted".format(dumps_to_del))
    for file in dumps_to_del:
        # TODO: Just as a sanity check, see if no other process is using this file
        os.remove(file)
    syslog.syslog(syslog.LOG_INFO, "/var/dump/ cleanup is performed. {} old dumps are deleted, current size of /var/dump/ dir is {}".format(num_del, num_cur_ts))
    return 


### Helper methods 
def wait_until_fd_is_free():
    pass

def subprocess_exec(cmd):
    output = subprocess.run(
        cmd,
        capture_output=True,
        text=True
    )
    return output.returncode, output.stdout, output.stderr

def diff(li1, li2):
    return list(set(li1) - set(li2)) + list(set(li2) - set(li1))

def verify_recent_file_creation(file_path, in_last_sec=20):
    curr = time.time()
    try:
        was_created_on = os.path.getmtime(file_path)
    except:
        return False
    
    if curr - was_created_on < in_last_sec:
        return True 
    else:
        return False
    