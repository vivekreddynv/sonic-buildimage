#!/usr/bin/env python3

"""
auto-techsupport script.
    This script is invoked by the techsupport-monit.service & coredump-monit.service 
    for auto techsupport invocation and cleanup of techsupport & core dumps. 
    For more info, refer to the HLD
"""
import sys
import glob
import time
import argparse
import subprocess
import syslog
from swsscommon.swsscommon import SonicV2Connector
from compiler.ast import Pass
from __builtin__ import True

AUTO_TS = "AUTO_TECHSUPPORT|global"
CFG_DB = "CONFIG_DB"
STATE_DB = "STATE_DB"
MAX_TS = "max-techsupports"
LAST_TS = "last_techsupport_run"
PREV_TS_COUNT = "num_techsupports"
CORE_FILE_LIST = "core_file_list"
TS_DIR = "/var/dump"
CORE_DUMP_DIR = "/var/core"
TS_PTRN = "sonic_dump_*.tar.gz"
CORE_DUMP_PTRN = "*.core.gz"
TS_WAIT_TIMEOUT = 300

DEFAULT_SCHEMA_STATE = {PREV_TS_COUNT : "", LAST_TS : "", CORE_FILE_LIST : ""} 


def main():
    parser = argparse.ArgumentParser(description='Auto Techsupport Invocation and Management Script')
    parser.add_argument('mode', type=str, choices=['core', 'techsupport'])
    args = parser.parse_args()
    
    syslog.openlog(logoption=syslog.LOG_PID)
    
    if args.mode == "core":
        handle_core_dump_creation_event()
    else:
        handle_techsupport_creation_event()
    
def handle_core_dump_creation_event():
    pass

def handle_techsupport_creation_event():
    """ 
    This method is invoked notified when there is a notification from systemd when something is changed in /var/dump/ directory
    Only if the feature is enabled by the user, the Techsupport cleanup process will be initiated. 
    The TS cleanup proces will delete the old techsupport dumps, when the actual number crosses the 'max-techsupports' limit configured by the user.
    Otherwise, just the state-db info is updated i.e. last_techsupport_run & num_techsupports  
    """
    last_ts = str(time.monotonic())
    
    curr_list = glob.glob(os.path.join(TS_DIR, TS_PTRN))
    curr_list.sort()
    num_cur_ts = len(curr_list)
    
    if curr_list == 0:
        syslog.syslog(syslog.LOG_DEBUG, "Ignoring the notification, as it wasn't because of the Techsupport dump creation")
        sys.exit(0) 
    
    # Note: The notification can still be a spurious one, but we don't know it yet
    # To determine this, we could use PREV_TS_COUNT in the state DB
    state_db = SonicV2Connector(host="127.0.0.1")
    state_db.connect(STATE_DB)
        
    if not state_db.exists(STATE_DB, AUTO_TS): # if the table doesn't exist, create one
        # Since the table is not yet created, we've no previous state information.
        # Thus, to find if the notification is not a spurious one, check if any relevant TS Dump has been created within the last 20 sec. 
        if not verify_recent_file_creation("TS"):
            syslog.syslog(syslog.LOG_DEBUG, "Ignoring the notification, as it wasn't because of the Techsupport dump creation")
            state_db.hmset(STATE_DB, AUTO_TS, {PREV_TS_COUNT : str(num_cur_ts), LAST_TS : "", CORE_FILE_LIST : ""})
            sys.exit(0)
        else: 
            state_db.hmset(STATE_DB, AUTO_TS, {PREV_TS_COUNT : str(num_cur_ts-1), LAST_TS : "", CORE_FILE_LIST : ""})
    else:
        prev_ts_count = state_db.get(STATE_DB, AUTO_TS, PREV_TS_COUNT)
        if prev_ts_count == num_cur_ts:
            syslog.syslog(syslog.LOG_DEBUG, "Ignoring the notification, as it wasn't because of the Techsupport dump creation")
            sys.exit(0)
    
    # If the program reached here, a new TS dump has been created  
    ts_dump_name = curr_list[-1] 
    cfg_db.set(STATE_DB, AUTO_TS, LAST_TS, last_ts, True) # Set the Last Techsupport Run time
    cfg_db.set(STATE_DB, AUTO_TS, PREV_TS_COUNT, num_cur_ts, True) # Set the Number of Techsupport runs
    syslog.syslog(syslog.LOG_INFO, "{} creation was made at monotonic time: {} sec".format(ts_dump_name, last_ts))
    
    cfg_db = SonicV2Connector(host="127.0.0.1")
    cfg_db.connect(CFG_DB)
    
    if cfg_db.get(CFG_DB, AUTO_TS, "state") == "enabled":
        max_ts = cfg_db.get(CFG_DB, AUTO_TS, MAX_TS)
        if not max_ts:
            syslog.syslog(syslog.LOG_INFO, "max-techsupports is not set. No TechSupport Cleanup Process is performed")
            sys.exit(0) 
    else:
        syslog.syslog(syslog.LOG_INFO, "AUTO_TECHSUPPORT is not enabled. No TechSupport Cleanup Process is performed")
        sys.exit(0)
    
    # Cleanup Checks
    curr_list = glob.glob(os.path.join(TS_DIR, TS_PTRN))
    curr_list.sort()
    num_cur_ts = len(curr_list)
    num_del = num_cur_ts - max_ts
    if num_del == 0:
        sys.exit(0)
    
    # Perform Cleanup
    dumps_to_del = curr_list[0:num_del]
    syslog.syslog(syslog.LOG_DEBUG, "{} dumps will be deleted".format(dumps_to_del))
    for file in dumps_to_del:
        os.remove(file)
    cfg_db.set(STATE_DB, AUTO_TS, PREV_TS_COUNT, max_ts, True) # Update the number of TS Dumps
    sys.exit(0)

### Helper methods

def wait_until_fd_is_free():
    pass

def diff(li1, li2):
    return list(set(li1) - set(li2)) + list(set(li2) - set(li1))

def verify_recent_file_creation(file_type, in_last_min=0.33):
    
    if file_type == "TS":
        dir = TS_DIR
        ptrn= TS_PTRN
    elif file_type == "CORE":
        dir = CORE_DUMP_DIR
        ptrn = CORE_DUMP_PTRN
    else:
        return False

    output = subprocess.run(["find", dir , "-mmin", "-{}".format(in_last_min), "-type", "f", "-name", "{}".format(ptrn)], capture_output=True)
    
    if output.stdout.decode("utf-8"):
        return True
    else:
        return False
    